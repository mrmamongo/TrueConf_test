# Тестовое задание для TrueConf
Решение должно соответствовать следующим условиям:
- Использование стандарта не новее C++17;
- Отсутствие зависимостей помимо стандартной библиотеки;
- Результат должен быть представлен в виде одного файла с
  исходным кодом;
- Программа должна компилироваться и стабильно работать.

## Задание.
На вход программе передается аргумент с именем файла.

Файл состоит из пар строк, ключ-значение, которые разделены пробелом.
Кодировка файла **ASCII**, размер ограничен **2^31 байт**.

Ключи состоят из **маленьких латинских букв**. Пара ключей x и y считается
эквивалентной,
если существует такая перестановка символов для y, что строки будут
посимвольно равны.

Пример эквивалентности:
**"abc" == "acb" == "bac" == "bca" == "cab" == "cba";**

Пример отсутствия эквивалентности:
**"abc" != "aabc";
"abcc" != "aabc";**

Необходимо:
1. Считать данные;
2. Преобразовать пары с эквивалентными ключами следующим образом:
    1. Оставить пару, соответствующую первому встреченному
       эквивалентному ключу;
    2. Удалить все другие пары с эквивалентным ключом. Значения из
       них добавить к первой паре и
       упорядочить в алфавитном порядке.

   Преобразование должно быть стабильным, то есть, пары, при выводе,
   за исключением удаленных, должны
   соответствовать порядку в котором они определены в исходном файле.

3. Вывести преобразованные данные в **stdout** в формате, соответствующем
   формату файла.

## Примеры работы программы
### Пример 1.
Пример файла:
```
» cat test1.txt
de a
xx zz
ed c
de b
```
Вывод.
```
./a.out test1.txt
de abc
xx zz
```
---
### Пример 2.
Пример файла:
```
» cat test2.txt
dead a
beef b
eadd z
xxxx c
ddea c
```
Вывод.
```
./a.out test2.txt
dead acz
beef b
xxxx c
```
---
### Пример 3.
Пример файла:
```
» cat test3.txt
one dead
two beef
three xxx
one a
one b
one c
```
Вывод.
```
./a.out test3.txt
one abcdead
two beef
three xxx
```
Здесь вопрос. Не должен ли быть вывод
```
one aabcdde
two beef
three xxx
```
Вот таким?
